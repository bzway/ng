---
layout: wechat
title: 文档基础结构设计
tags=test
---





# 对象object

Objects are  PUT in Fast Data Store are immutable. This means that an ID is generated by the caller can not be changed any more. This greatly simplifies the internal system design and helps to keep everything decentralized. The ID has the appropriate information encoded in it that helps to locate a blob on a GET. 

对象更新到快数存储后不可变更，同时也意味着由触发者生成的ID不可变。这大大简化了内部系统设计也可以保证存储内容去中心化。ID中包含适当的定位信息，有助于快速定位存储空间。

# 存储

存储分两类，一类小文件的块存储。一类大文件直接存储。存储成功后需要更新索引文件。

## 存储索引

The index is designed as a set of sorted files. The most recent index segment is in memory. The older segments are memory mapped and an entry is located by doing a binary search on them. 

存储索引被设计成有序数列。为了性能通常在内存中。为了空间，不常用数据会内存影射到文件，只在二分查找时加载数据。

Each index segment also contains a bloom filter to optimize on IO. The bloom filters are read to memory on startup. 

存储索引中也可以包括布朗过滤来优化磁盘的读写。布朗过滤在系统启动时加载。

Data Store serves two purpose - as data store and also as the transaction log to recover the index on a crash.

数据存储扮演两个角色，一是原始数据，二是元数据，用于索引恢复。


| 类型   | 长度      | 说明          |
| ------ | --------- | ------------- |
| FileID | (8 bytes) | 文件编号      |
| Flags  | (1 byte)  | 类型 0 为删除 |
| TTL    | (8 bytes) | 时间戳        |
| Offset | (8 bytes) | Refer |
|    |           |         |

| 类型   | 长度      | 说明          |
| ------ | --------- | ------------- |
| FileID | (8 bytes) | 文件编号      |
| Flags  | (1 byte)  | 0=删除;1=File;2=Data;3=ZIP |
| TTL    | (8 bytes) | 时间戳        |
| Offset | (8 bytes) |               |
| Salt   | (8 bytes) |         |
| HeadSize | (8 bytes) | 头内部长度 |
| Header | (n bytes) | 头内容 |
| CRC| (8 bytes) | 循环冗余校验 |
| Size | (6 bytes) | 内容长度 |
| Body | (n bytes) | 内容 |


## 存储优化

**Zero copy for gets** The store is designed to read the data and directly transfer the bytes to the socket during gets. This ensures that we could push bytes to the socket with fewer system calls as well as reduce the memory footprint. This speeds up the read request and helps in the total end to end latency.

读取时零复制，文件读取流保持常开，数据直接传到socket返回。减少系统调用，减少内存转换。

**Using fallocate to preallocate the data**  We get pretty good write throughput since our writes are sequential. 

## 块存储

在磁盘上创建一个大文件，将所有小文件数据压缩到这个大文件中。

## 直接存储

首先在块中存储一个基于文件内容的引用，然后独立存储文件。





|   size  |  log offset |  flags   |  timetolive |originalMessageOffset  |
| ------- | ----- | ---- | ------ |
|(8 bytes)|  (8 bytes)  |  (1 byte)|  (8 bytes)  |         (8 bytes)        |
size                    - the entry size in memory
log offset              - the offset in the log where the blob can be read
flags                   - a byte sized flag used for marking properties. Currently used for delete.
time to live            - the time in ms when the blob will expire
original message offset - the offset of the original message. This is used when a new entry is added for deletes and the 
​                          deleted blob needs to be located in the log.



| version | keysize | valuesize | fileendpointer |   key 1  | value 1  |  ...  |   key n   | value n   | crc      |
| ------- | ----- | ---- | ------ |
|(2 bytes)|(4 bytes)| (4 bytes) |    (8 bytes)   | (n bytes)| (n bytes)|       | (n bytes) | (n bytes) | (8 bytes)|

version         - the index format version
keysize         - the size of the key in this index segment
valuesize       - the size of the value in this index segment
fileendpointer  - the log end pointer that pertains to the index being persisted
key n / value n - the key and value entries contained in this index segment
crc             - the crc of the index segment content